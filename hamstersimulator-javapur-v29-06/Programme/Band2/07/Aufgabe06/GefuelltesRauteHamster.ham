/*class*/class GefuelltesRauteHamster extends RauteHamster {
    // Konstruktor
    GefuelltesRauteHamster(int r, int s, int b, int k) {
        super(r, s, b, k);
    }

    // zeichnet ab der Kachel (r/s) mit Koernern ein Quadrat
    // mit der angegebenen Seitenlaenge;
    // das Quadrat wird dabei mit Koernern gefuellt;
    // der Hamster tut nichts und liefert false, wenn er
    // nicht genuegend Koerner zum Zeichnen im Maul hat oder
    // ab der angegebenen Kachel nicht mehr genuegend Platz ist
    boolean zeichne(int r, int s, int radius) {
        if (radius <= 0 || !this.genuegendKoernerImMaul(radius)
                || !this.genuegendPlatz(r, s, radius)) {
            return false;
        }

        this.merkenDerStartPosition();
        this.laufeZuKachel(r, s);
        this.setzeBlickrichtung(Hamster.OST);
        while (radius > 0) {
            super.zeichneWirklich(radius);
            radius = radius - 1;
            this.laufeZuKachel(r, s);
            if (radius == 0) {
                this.gib();
            }
        }
        this.geheZurStartPosition();
        return true;
    }
    
    // alternative Implementierung; aber nicht optimiert, da der
    // Hamster nach jedem Aufruf der geerbten Methode zeichne
    // wieder zunaechst zur Ausgangsposition laeuft
    /*
    boolean zeichnex(int r, int s, int radius) {
        if (radius <= 0 || !this.genuegendKoernerImMaul(radius)
                || !this.genuegendPlatz(r, s, radius)) {
            return false;
        }
        while (radius > 0) {
            super.zeichne(r, s, radius);
            radius = radius - 2;
            r = r + 1;
            s = s + 1;
        }
        return true;
    }
    */

    // Hilfsmethoden
    
    // muss ueberschrieben werden
    boolean genuegendKoernerImMaul(int radius) {
        return (radius * radius) + (radius - 1) * (radius - 1) <= this.getAnzahlKoerner();
    }
}